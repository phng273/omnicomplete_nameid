"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDb = exports.getDbSignalPath = exports.getDbPath = exports.evalsToDatasetsRelations = exports.evalsToDatasets = exports.evalsToPromptsRelations = exports.evalsToPrompts = exports.evalsRelations = exports.evals = exports.datasetsRelations = exports.datasets = exports.promptsRelations = exports.prompts = void 0;
const node_path_1 = __importDefault(require("node:path"));
const drizzle_orm_1 = require("drizzle-orm");
const sqlite_core_1 = require("drizzle-orm/sqlite-core");
const better_sqlite3_1 = require("drizzle-orm/better-sqlite3");
const better_sqlite3_2 = __importDefault(require("better-sqlite3"));
const util_1 = require("./util");
// ------------ Prompts ------------
exports.prompts = (0, sqlite_core_1.sqliteTable)('prompts', {
    id: (0, sqlite_core_1.text)('id').primaryKey(),
    createdAt: (0, sqlite_core_1.integer)('created_at')
        .notNull()
        .default((0, drizzle_orm_1.sql) `CURRENT_TIMESTAMP`),
    prompt: (0, sqlite_core_1.text)('prompt').notNull(),
});
exports.promptsRelations = (0, drizzle_orm_1.relations)(exports.prompts, ({ many }) => ({
    evalsToPrompts: many(exports.evalsToPrompts),
}));
// ------------ Datasets ------------
exports.datasets = (0, sqlite_core_1.sqliteTable)('datasets', {
    id: (0, sqlite_core_1.text)('id').primaryKey(),
    tests: (0, sqlite_core_1.text)('tests', { mode: 'json' }).$type(),
    createdAt: (0, sqlite_core_1.integer)('created_at')
        .notNull()
        .default((0, drizzle_orm_1.sql) `CURRENT_TIMESTAMP`),
});
exports.datasetsRelations = (0, drizzle_orm_1.relations)(exports.datasets, ({ many }) => ({
    evalsToDatasets: many(exports.evalsToDatasets),
}));
// ------------ Evals ------------
exports.evals = (0, sqlite_core_1.sqliteTable)('evals', {
    id: (0, sqlite_core_1.text)('id').primaryKey(),
    createdAt: (0, sqlite_core_1.integer)('created_at')
        .notNull()
        .default((0, drizzle_orm_1.sql) `CURRENT_TIMESTAMP`),
    description: (0, sqlite_core_1.text)('description'),
    results: (0, sqlite_core_1.text)('results', { mode: 'json' }).$type().notNull(),
    config: (0, sqlite_core_1.text)('config', { mode: 'json' }).$type().notNull(),
});
exports.evalsRelations = (0, drizzle_orm_1.relations)(exports.evals, ({ many }) => ({
    evalsToPrompts: many(exports.evalsToPrompts),
    evalsToDatasets: many(exports.evalsToDatasets),
}));
exports.evalsToPrompts = (0, sqlite_core_1.sqliteTable)('evals_to_prompts', {
    evalId: (0, sqlite_core_1.text)('eval_id')
        .notNull()
        .references(() => exports.evals.id),
    // Drizzle doesn't support this migration for sqlite, so we remove foreign keys manually.
    //.references(() => evals.id, { onDelete: 'cascade' }),
    promptId: (0, sqlite_core_1.text)('prompt_id')
        .notNull()
        .references(() => exports.prompts.id),
}, (t) => ({
    pk: (0, sqlite_core_1.primaryKey)({ columns: [t.evalId, t.promptId] }),
}));
exports.evalsToPromptsRelations = (0, drizzle_orm_1.relations)(exports.evalsToPrompts, ({ one }) => ({
    eval: one(exports.evals, {
        fields: [exports.evalsToPrompts.evalId],
        references: [exports.evals.id],
    }),
    prompt: one(exports.prompts, {
        fields: [exports.evalsToPrompts.promptId],
        references: [exports.prompts.id],
    }),
}));
exports.evalsToDatasets = (0, sqlite_core_1.sqliteTable)('evals_to_datasets', {
    evalId: (0, sqlite_core_1.text)('eval_id')
        .notNull()
        .references(() => exports.evals.id),
    // Drizzle doesn't support this migration for sqlite, so we remove foreign keys manually.
    //.references(() => evals.id, { onDelete: 'cascade' }),
    datasetId: (0, sqlite_core_1.text)('dataset_id')
        .notNull()
        .references(() => exports.datasets.id),
}, (t) => ({
    pk: (0, sqlite_core_1.primaryKey)({ columns: [t.evalId, t.datasetId] }),
}));
exports.evalsToDatasetsRelations = (0, drizzle_orm_1.relations)(exports.evalsToDatasets, ({ one }) => ({
    eval: one(exports.evals, {
        fields: [exports.evalsToDatasets.evalId],
        references: [exports.evals.id],
    }),
    dataset: one(exports.datasets, {
        fields: [exports.evalsToDatasets.datasetId],
        references: [exports.datasets.id],
    }),
}));
// ------------ Outputs ------------
// We're just recording these on eval.results for now...
/*
export const llmOutputs = sqliteTable(
  'llm_outputs',
  {
    id: text('id')
      .notNull()
      .unique(),
    createdAt: integer('created_at').notNull().default(sql`CURRENT_TIMESTAMP`),
    evalId: text('eval_id')
      .notNull()
      .references(() => evals.id),
    promptId: text('prompt_id')
      .notNull()
      .references(() => prompts.id),
    providerId: text('provider_id').notNull(),
    vars: text('vars', {mode: 'json'}),
    response: text('response', {mode: 'json'}),
    error: text('error'),
    latencyMs: integer('latency_ms'),
    gradingResult: text('grading_result', {mode: 'json'}),
    namedScores: text('named_scores', {mode: 'json'}),
    cost: real('cost'),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.id] }),
  }),
);

export const llmOutputsRelations = relations(llmOutputs, ({ one }) => ({
  eval: one(evals, {
    fields: [llmOutputs.evalId],
    references: [evals.id],
  }),
  prompt: one(prompts, {
    fields: [llmOutputs.promptId],
    references: [prompts.id],
  }),
}));
*/
let dbInstance = null;
function getDbPath() {
    return node_path_1.default.resolve((0, util_1.getConfigDirectoryPath)(), 'promptfoo.db');
}
exports.getDbPath = getDbPath;
function getDbSignalPath() {
    return node_path_1.default.resolve((0, util_1.getConfigDirectoryPath)(), 'evalLastWritten');
}
exports.getDbSignalPath = getDbSignalPath;
function getDb() {
    if (!dbInstance) {
        const sqlite = new better_sqlite3_2.default(getDbPath());
        dbInstance = (0, better_sqlite3_1.drizzle)(sqlite);
    }
    return dbInstance;
}
exports.getDb = getDb;
//# sourceMappingURL=database.js.map