{"version":3,"sources":["rouge.js"],"names":[],"mappings":"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","file":"rouge.js","sourcesContent":["/**\n* @flow\n* @license\n* @Author: Lim Mingjie, Kenneth\n* @Date:   2016-01-20T18:56:14-05:00\n* @Email:  me@kenlimmj.com\n* @Last modified by:   Astrianna\n* @Last modified time: 2016-02-27T19:50:25-05:00\n*/\n\nimport * as utils from './utils';\nexport * from './utils';\n\n/**\n * Computes the ROUGE-N score for a candidate summary.\n *\n * Configuration object schema and defaults:\n * ```\n * {\n * \tn: 1                            // The size of the ngram used\n * \tnGram: <inbuilt function>,      // The ngram generator function\n * \ttokenizer: <inbuilt function>   // The string tokenizer\n * }\n * ```\n *\n * `nGram` has a type signature of ((Array<string>, number) => Array<string>)\n * `tokenizer` has a type signature of ((string) => Array<string)\n *\n * @method n\n * @param  {string}     cand        The candidate summary to be evaluated\n * @param  {string}     ref         The reference summary to be evaluated against\n * @param  {Object}     opts        Configuration options (see example)\n * @return {number}                 The ROUGE-N score\n */\nexport function n(\n  cand: string,\n  ref: string,\n  opts: {\n    n: number,\n    nGram: ((tokens: Array<string>, n: number) => Array<string>),\n    tokenizer: ((input: string) => Array<string>)\n  }\n): number {\n  if (cand.length === 0) throw new RangeError('Candidate cannot be an empty string');\n  if (ref.length === 0) throw new RangeError('Reference cannot be an empty string');\n\n  // Merge user-provided configuration with defaults\n  opts = Object.assign({\n    n: 1,\n    nGram: utils.nGram,\n    tokenizer: utils.treeBankTokenize,\n  }, opts);\n\n  const candGrams = opts.nGram(opts.tokenizer(cand), opts.n);\n  const refGrams = opts.nGram(opts.tokenizer(ref), opts.n);\n\n  const match = utils.intersection(candGrams, refGrams);\n  return match.length / refGrams.length;\n}\n\n/**\n * Computes the ROUGE-S score for a candidate summary.\n *\n * Configuration object schema and defaults:\n * ```\n * {\n * \tbeta: 1                             // The beta value used for the f-measure\n * \tgapLength: 2                        // The skip window\n * \tskipBigram: <inbuilt function>,     // The skip-bigram generator function\n * \ttokenizer: <inbuilt function>       // The string tokenizer\n * }\n * ```\n *\n * `skipBigram` has a type signature of ((Array<string>, number) => Array<string>)\n * `tokenizer` has a type signature of ((string) => Array<string)\n *\n * @method s\n * @param  {string}     cand        The candidate summary to be evaluated\n * @param  {string}     ref         The reference summary to be evaluated against\n * @param  {Object}     opts        Configuration options (see example)\n * @return {number}                 The ROUGE-S score\n */\nexport function s(\n  cand: string,\n  ref: string,\n  opts: {\n    beta: number,\n    skipBigram: ((tokens: Array<string>) => Array<string>),\n    tokenizer: ((input: string) => Array<string>)\n  }\n): number {\n  if (cand.length === 0) throw new RangeError('Candidate cannot be an empty string');\n  if (ref.length === 0) throw new RangeError('Reference cannot be an empty string');\n\n  // Merge user-provided configuration with defaults\n  opts = Object.assign({\n    beta: 0.5,\n    skipBigram: utils.skipBigram,\n    tokenizer: utils.treeBankTokenize,\n  }, opts);\n\n  const candGrams = opts.skipBigram(opts.tokenizer(cand));\n  const refGrams = opts.skipBigram(opts.tokenizer(ref));\n\n  const skip2 = utils.intersection(candGrams, refGrams).length;\n\n  if (skip2 === 0) {\n    return 0;\n  } else {\n    const skip2Recall = skip2 / refGrams.length;\n    const skip2Prec = skip2 / candGrams.length;\n\n    return utils.fMeasure(skip2Prec, skip2Recall, opts.beta);\n  }\n}\n\n/**\n * Computes the ROUGE-L score for a candidate summary\n *\n * Configuration object schema and defaults:\n * ```\n * {\n * \tbeta: 1                             // The beta value used for the f-measure\n * \tlcs: <inbuilt function>             // The least common subsequence function\n * \tsegmenter: <inbuilt function>,      // The sentence segmenter\n * \ttokenizer: <inbuilt function>       // The string tokenizer\n * }\n * ```\n *\n * `lcs` has a type signature of ((Array<string>, Array<string>) => Array<string>)\n * `segmenter` has a type signature of ((string) => Array<string)\n * `tokenizer` has a type signature of ((string) => Array<string)\n *\n * @method l\n * @param  {string}     cand        The candidate summary to be evaluated\n * @param  {string}     ref         The reference summary to be evaluated against\n * @param  {Object}     opts        Configuration options (see example)\n * @return {number}                 The ROUGE-L score\n */\nexport function l(\n  cand: string,\n  ref: string,\n  opts: {\n    beta: number,\n    lcs: ((a: Array<string>, b: Array<string>) => Array<string>),\n    segmenter: ((input: string) => Array<string>),\n    tokenizer: ((input: string) => Array<string>)\n  }\n): number {\n  if (cand.length === 0) throw new RangeError('Candidate cannot be an empty string');\n  if (ref.length === 0) throw new RangeError('Reference cannot be an empty string');\n\n  // Merge user-provided configuration with defaults\n  opts = Object.assign({\n    beta: 0.5,\n    lcs: utils.lcs,\n    segmenter: utils.sentenceSegment,\n    tokenizer: utils.treeBankTokenize,\n  }, opts);\n\n  const candSents = opts.segmenter(cand);\n  const refSents = opts.segmenter(ref);\n\n  const candWords = opts.tokenizer(cand);\n  const refWords = opts.tokenizer(ref);\n\n  const lcsAcc = refSents.map(r => {\n    const rTokens = opts.tokenizer(r);\n    const lcsUnion = new Set(...candSents.map(c => opts.lcs(opts.tokenizer(c), rTokens)));\n\n    return lcsUnion.size;\n  });\n\n  // Sum the array as quickly as we can\n  let lcsSum = 0;\n  while (lcsAcc.length) lcsSum += lcsAcc.pop();\n\n  const lcsRecall = lcsSum / candWords.length;\n  const lcsPrec = lcsSum / refWords.length;\n\n  return utils.fMeasure(lcsPrec, lcsRecall, opts.beta);\n}\n"],"sourceRoot":"/source/"}