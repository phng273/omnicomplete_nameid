{"version":3,"sources":["utils.js"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["/**\n* @flow\n* @license\n* @Author: Lim Mingjie, Kenneth\n* @Date:   2016-01-20T18:56:22-05:00\n* @Email:  me@kenlimmj.com\n* @Last modified by:   Astrianna\n* @Last modified time: 2016-02-27T19:55:12-05:00\n*/\n\nimport {\n  GATE_SUBSTITUTIONS,\n  GATE_EXCEPTIONS,\n  TREEBANK_CONTRACTIONS,\n} from './constants';\n\n/**\n * Splits a sentence into an array of word tokens\n * in accordance with the Penn Treebank guidelines.\n *\n * NOTE: This method assumes that the input is a single\n * sentence only. Providing multiple sentences within a\n * single string can trigger edge cases which have not\n * been accounted for.\n *\n * Adapted from Titus Wormer's port of the Penn Treebank Tokenizer\n * found at https://gist.github.com/wooorm/8504606\n *\n *\n * @method treeBankTokenize\n * @param  {string}           input     The sentence to be tokenized\n * @return {Array<string>}              An array of word tokens\n */\nexport function treeBankTokenize(input: string): Array<string> {\n  if (input.length === 0) return [];\n\n  // Does the following things in order of appearance by line:\n  // 1. Replace quotes at the sentence start position with double ticks\n  // 2. Wrap spaces around a double quote preceded by opening brackets\n  // 3. Wrap spaces around a non-unicode ellipsis\n  // 4. Wrap spaces around some punctuation signs (,;@#$%&)\n  // 5. Wrap spaces around a period and zero or more closing brackets\n  //    (or quotes), when not preceded by a period and when followed\n  //    by the end of the string. Only splits final periods because\n  //    sentence tokenization is assumed as a preprocessing step\n  // 6. Wrap spaces around all exclamation marks and question marks\n  // 7. Wrap spaces around opening and closing brackets\n  // 8. Wrap spaces around en and em-dashes\n  let parse = input.replace(/^\\\"/, ' `` ')\n                   .replace(/([ (\\[{<])\"/g, '$1 `` ')\n                   .replace(/\\.\\.\\.*/g, ' ... ')\n                   .replace(/[;@#$%&]/g, ' $& ')\n                   .replace(/([^\\.])(\\.)([\\]\\)}>\"\\']*)\\s*$/g, '$1 $2$3 ')\n                   .replace(/[,?!]/g, ' $& ')\n                   .replace(/[\\]\\[\\(\\)\\{\\}<>]/g, ' $& ')\n                   .replace(/---*/g, ' -- ');\n\n  // Wrap spaces at the start and end of the sentence for consistency\n  // i.e. reduce the number of Regex matches required\n  parse = ` ${parse} `;\n\n  // Does the following things in order of appearance by line:\n  // 1. Replace double quotes with a pair of single quotes wrapped with spaces\n  // 2. Wrap possessive or closing single quotes\n  // 3. Add a space before single quotes followed by `s`, `m`, or `d` and a space\n  // 4. Add a space before occurrences of `'ll`, `'re`, `'ve` or `n't`\n  parse = parse.replace(/\"/g, ' \\'\\' ')\n               .replace(/([^'])' /g, '$1 \\' ')\n               .replace(/'([sSmMdD]) /g, ' \\'$1 ')\n               .replace(/('ll|'LL|'re|'RE|'ve|'VE|n't|N'T) /g, ' $1 ');\n\n  let iterator = -1;\n  while (iterator++ < TREEBANK_CONTRACTIONS.length) {\n    // Break uncommon contractions with a space and wrap-in spaces\n    parse = parse.replace(TREEBANK_CONTRACTIONS[iterator], ' $1 $2 ');\n  }\n\n  // Concatenate double spaces and remove start/end spaces\n  parse = parse.replace(/\\ \\ +/g, ' ')\n               .replace(/^\\ |\\ $/g, '');\n\n  // Split on spaces (original and inserted) to return the tokenized result\n  return parse.split(' ');\n}\n\n/**\n * Splits a body of text into an array of sentences\n * using a rule-based segmentation approach.\n *\n * Adapted from Spencer Mountain's nlp_compromise library\n * found at https://github.com/spencermountain/nlp_compromise/\n *\n * @method sentenceSegment\n * @param  {string}         input     The document to be segmented\n * @return {Array<string>}            An array of sentences\n */\nexport function sentenceSegment(input: string): Array<string> {\n  if (input.length === 0) return [];\n\n  const abbrvReg = new RegExp('\\\\b(' + GATE_SUBSTITUTIONS.join('|') + ')[.!?] ?$', 'i');\n  const acronymReg = new RegExp(/[ |.][A-Z].?$/, 'i');\n  const breakReg = new RegExp(/[\\r\\n]+/, 'g');\n  const ellipseReg = new RegExp(/\\.\\.\\.*$/);\n  const excepReg = new RegExp('\\\\b(' + GATE_EXCEPTIONS.join('|') + ')[.!?] ?$', 'i');\n\n  // Split sentences naively based on common terminals (.?!\")\n  let chunks = input.split(/(\\S.+?[.?!])(?=\\s+|$|\")/g);\n  console.log(chunks);\n  let acc = [];\n  for (let idx = 0; idx < chunks.length; idx++) {\n    if (chunks[idx]) {\n      // Trim only whitespace (i.e. preserve line breaks/carriage feeds)\n      chunks[idx] = chunks[idx].replace(/(^ +| +$)/g, '');\n\n      if (breakReg.test(chunks[idx])) {\n        if (chunks[idx + 1] && strIsTitleCase(chunks[idx])) {\n          // Catch line breaks embedded within valid sentences\n          // i.e. sentences that start with a capital letter\n          // and merge them with a delimiting space\n          chunks[idx + 1] = (chunks[idx].trim() || '') + ' ' + (chunks[idx + 1] || '').replace(/ +/g, ' ');\n        } else {\n          // Assume that all other embedded line breaks are\n          // valid sentence breakpoints\n          acc.push(...chunks[idx].trim().split('\\n'));\n        }\n      } else if (chunks[idx + 1] && abbrvReg.test(chunks[idx])) {\n        const nextChunk = chunks[idx + 1];\n        if (nextChunk.trim() && strIsTitleCase(nextChunk) && !excepReg.test(chunks[idx])) {\n          // Catch abbreviations followed by a capital letter and treat as a boundary.\n          // FIXME: This causes named entities like `Mt. Fuji` or `U.S. Government` to fail.\n          acc.push(chunks[idx]);\n          chunks[idx] = '';\n        } else {\n          // Catch common abbreviations and merge them with a delimiting space\n          chunks[idx + 1] = (chunks[idx] || '') + ' ' + (nextChunk || '').replace(/ +/g, ' ');\n        }\n      } else if (chunks[idx].length > 1 && chunks[idx + 1] && acronymReg.test(chunks[idx])) {\n        const words = chunks[idx].split(' ');\n        const lastWord = words[words.length - 1];\n\n        if (lastWord === lastWord.toLowerCase()) {\n          // Catch small-letter abbreviations and merge them.\n          chunks[idx + 1] = chunks[idx + 1] = (chunks[idx] || '') + ' ' + (chunks[idx + 1] || '').replace(/ +/g, ' ');\n        } else if (chunks[idx + 2]) {\n          if (strIsTitleCase(words[words.length - 2]) && strIsTitleCase(chunks[idx + 2])) {\n            // Catch name abbreviations (e.g. Albert I. Jones) by checking if\n            // the previous and next words are all capitalized.\n            chunks[idx + 2] = (chunks[idx] || '') + (chunks[idx + 1] || '').replace(/ +/g, ' ') + (chunks[idx + 2] || '');\n          } else {\n            // Assume that remaining entities are indeed end-of-sentence markers.\n            acc.push(chunks[idx]);\n            chunks[idx] = '';\n          }\n        }\n      } else if (chunks[idx + 1] && ellipseReg.test(chunks[idx])) {\n        // Catch mid-sentence ellipses (and their derivatives) and merge them\n        chunks[idx + 1] = (chunks[idx] || '') + (chunks[idx + 1] || '').replace(/ +/g, ' ');\n      } else if (chunks[idx] && chunks[idx].length > 0) {\n        acc.push(chunks[idx]);\n        chunks[idx] = '';\n      }\n    }\n  }\n\n  // If no matches were found, return the input treated as a single sentence\n  return acc.length === 0 ? [input] : acc;\n}\n\n/**\n * Checks if a string is titlecase\n * @method strIsTitleCase\n * @param  {string}   input       The string to be checked\n * @return {boolean}              True if the string is titlecase and false otherwise\n */\nexport function strIsTitleCase(input: string): boolean {\n  const firstChar = input.trim().slice(0, 1);\n  return charIsUpperCase(firstChar);\n}\n\n/**\n * Checks if a character is uppercase\n * @method charIsUpperCase\n * @param  {string}   input     The character to be tested\n * @return {boolean}            True if the character is uppercase and false otherwise.\n */\nexport function charIsUpperCase(input: string): boolean {\n  if (input.length !== 1) throw new RangeError('Input should be a single character');\n\n  const char = input.charCodeAt(0);\n  return char >= 65 && char <= 90;\n}\n\n/**\n * Memoizes a function using a Map\n *\n * @method memoize\n * @param  {Function} func    The function to be memoized\n * @param  {Function} Store   The data store constructor. Defaults to the ES6-inbuilt Map function.\n *                            A store should implement `has`, `get`, and `set` methods.\n * @return {Function}         A closure of the memoization cache and the original function\n */\nfunction memoize(func: Function, Store: Function = Map): Function {\n  return (() => {\n    let cache = new Store();\n\n    return (n) => {\n      if (cache.has(n)) {\n        return cache.get(n);\n      } else {\n        let result = func(n);\n        cache.set(n, result);\n        return result;\n      }\n    };\n  })();\n}\n\n/**\n * Computes the factorial of a number.\n *\n * This function uses a tail-recursive call to avoid\n * blowing the stack when computing inputs with a large\n * recursion depth.\n *\n * If this function will be called repeatedly within\n * the same scope, it is highly recommended that the\n * user memoize the function (e.g. lodash.memoize).\n *\n * @method factRec\n * @param  {number} x     The number for which the factorial is to be computed\n * @param  {number} acc   The starting value for the computation. Defaults to 1.\n * @return {number}       The factorial result\n */\nfunction factRec(\n  x: number,\n  acc: number = 1\n): number {\n  if (x < 0) throw RangeError('Input must be a positive number');\n  return x < 2 ? acc : factRec(x - 1, x * acc);\n}\n\nexport const fact = memoize(factRec);\n\n/**\n * Returns the skip bigrams for an array of word tokens.\n *\n * @method skipBigram\n * @param  {Array<string>}    tokens      An array of word tokens\n * @return {Array<string>}                An array of skip bigram strings\n */\nexport function skipBigram(\n  tokens: Array<string>\n): Array<string> {\n  if (tokens.length < 2) throw new RangeError('Input must have at least two words');\n\n  let acc = [];\n  for (let baseIdx = 0; baseIdx < tokens.length - 1; baseIdx++) {\n    for (let sweepIdx = baseIdx + 1; sweepIdx < tokens.length; sweepIdx++) {\n      acc.push(`${tokens[baseIdx]} ${tokens[sweepIdx]}`);\n    }\n  }\n\n  return acc;\n}\n\nexport const NGRAM_DEFAULT_OPTS = { start: false, end: false, val: '<S>' };\n\n/**\n * Returns n-grams for an array of word tokens.\n *\n * @method nGram\n * @param  {Array<string>}          tokens    An array of word tokens\n * @param  {number}                 n         The size of the n-gram. Defaults to 2.\n * @param  {Object}                 pad       String padding options. See example.\n * @return {Array<string>}                    An array of n-gram strings\n */\nexport function nGram(\n  tokens: Array<string>,\n  n: number = 2,\n  pad: Object = {}\n): Array<string> {\n  if (n < 1) throw new RangeError('ngram size cannot be smaller than 1');\n\n  if (tokens.length < n) {\n    throw new RangeError('ngram size cannot be larger than the number of tokens available');\n  }\n\n  if (pad !== {}) {\n    const config = Object.assign({}, NGRAM_DEFAULT_OPTS, pad);\n\n    // Clone the input token array to avoid mutating the source data\n    let tempTokens = tokens.slice(0);\n\n    if (config.start) for (let i = 0; i < n - 1; i++) tempTokens.unshift(config.val);\n    if (config.end) for (let i = 0; i < n - 1; i++) tempTokens.push(config.val);\n\n    tokens = tempTokens;\n  }\n\n  let acc = [];\n  for (let idx = 0; idx < (tokens.length - n + 1); idx++) {\n    acc.push(tokens.slice(idx, idx + n).join(' '));\n  }\n\n  return acc;\n}\n\n/**\n * Calculates C(val, 2), i.e. the number of ways 2\n * items can be chosen from `val` items.\n *\n * @method comb2\n * @param  {number} val     The total number of items to choose from\n * @return {number}         The number of ways in which 2 items can be chosen from `val`\n */\nexport function comb2(val: number): number {\n  if (val < 2) throw new RangeError('Input must be greater than 2');\n  return 0.5 * val * (val - 1);\n}\n\n/**\n * Computes the arithmetic mean of an array\n * @method arithmeticMean\n * @param  {Array<number>}   input    Data distribution\n * @return {number}                   The mean of the distribution\n */\nexport function arithmeticMean(input: Array<number>): number {\n  if (input.length < 1) throw new RangeError('Input array must have at least 1 element');\n  return input.reduce((x, y) => x + y) / input.length;\n}\n\n/**\n * Evaluates the jackknife resampling result for a set of\n * candidate summaries vs. a reference summary.\n *\n * @method jackKnife\n * @param  {Array<string>}  cands      An array of candidate summaries to be evaluated\n * @param  {string}         ref        The reference summary to be evealuated against\n * @param  {Function}       func       The function used to evaluate a candidate against a reference.\n *                                     Should be of the type signature (string, string) => number\n * @param  {Function}       test       The function used to compute the test statistic.\n *                                     Defaults to the arithmetic mean.\n *                                     Should be of the type signature (Array<number>) => number\n * @return {number}                    The result computed by applying `test` to the resampled data\n */\nexport function jackKnife(\n  cands: Array<string>,\n  ref: string,\n  func: ((x: string, y: string) => number),\n  test: ((x: Array<number>) => number) = arithmeticMean\n): number {\n  if (cands.length < 2) {\n    throw new RangeError('Candidate array must contain more than one element');\n  }\n\n  const pairs = cands.map(c => func(c, ref));\n\n  let acc = [];\n  for (let idx = 0; idx < pairs.length; idx++) {\n    // Clone the array and remove one element\n    let leaveOneOut = pairs.slice(0);\n    leaveOneOut.splice(idx, 1);\n\n    acc.push(Math.max(...leaveOneOut));\n  }\n\n  return test(acc);\n}\n\n/**\n * Calculates the ROUGE f-measure for a given precision\n * and recall score.\n *\n * DUC evaluation favors precision by setting beta to an\n * arbitary large number. To replicate this, set beta to\n * any value larger than 1.\n *\n * @method fMeasure\n * @param  {number}     p       Precision score\n * @param  {number}     r       Recall score\n * @param  {number}     beta    Weighing value (precision vs. recall).\n *                              Defaults to 0.5, i.e. mean f-score\n * @return {number}             Computed f-score\n */\nexport function fMeasure(\n  p: number,\n  r: number,\n  beta: number = 0.5\n): number {\n  if (p < 0 || p > 1) throw new RangeError('Precision value p must have bounds 0 ≤ p ≤ 1');\n  if (r < 0 || r > 1) throw new RangeError('Recall value r must have bounds 0 ≤ r ≤ 1');\n\n  if (beta < 0) {\n    throw new RangeError('beta value must be greater than 0');\n  } else if (0 <= beta && beta <= 1) {\n    return ((1 + beta * beta) * r * p) / (r + beta * beta * p);\n  } else {\n    return r;\n  }\n}\n\n/**\n * Computes the set intersection of two arrays\n *\n * @method intersection\n * @param  {Array<string>}    a     The first array\n * @param  {Array<string>}    b     The second array\n * @return {Array<string>}          Elements common to both the first and second array\n */\nexport function intersection(a: Array<string>, b: Array<string>): Array<string> {\n  const test = new Set(a);\n  const ref = new Set(b);\n\n  return Array.from(test).filter(elem => ref.has(elem));\n}\n\n/**\n * Computes the longest common subsequence for two arrays.\n * This function returns the elements from the two arrays\n * that form the LCS, in order of their appearance.\n *\n * For speed, the search-space is prunned by eliminating\n * common entities at the start and end of both input arrays.\n *\n * @method lcs\n * @param  {Array<string>}    a     The first array\n * @param  {Array<string>}    b     The second array\n * @return {Array<string>}          The longest common subsequence between the first and second array\n */\nexport function lcs(a: Array<string>, b: Array<string>): Array<string> {\n  if (a.length === 0 || b.length === 0) return [];\n\n  let start = [];\n  let end = [];\n\n  let startIdx = 0;\n  let aEndIdx = a.length - 1;\n  let bEndIdx = b.length - 1;\n\n  while (a[startIdx] && b[startIdx] && (a[startIdx] === b[startIdx])) {\n    start.push(a[startIdx]);\n    startIdx++;\n  }\n\n  while (a[aEndIdx] && b[bEndIdx] && (a[aEndIdx] === b[bEndIdx])) {\n    end.push(a[aEndIdx]);\n    aEndIdx--;\n    bEndIdx--;\n  }\n\n  let trimmedA = a.slice(startIdx, aEndIdx + 1);\n  let trimmedB = b.slice(startIdx, bEndIdx + 1);\n\n  for (let bIdx = 0; bIdx < trimmedB.length; bIdx++) {\n    for (let aIdx = 0; aIdx < trimmedA.length; aIdx++) {\n      if (trimmedB[bIdx] === trimmedA[aIdx]) start.push(trimmedA[aIdx]);\n    }\n  }\n\n  return start.concat(end);\n}\n"],"sourceRoot":"/source/"}